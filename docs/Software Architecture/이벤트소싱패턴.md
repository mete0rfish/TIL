# 개요
데이터 최종 상태를 저장하는 것이 아니라, 상태를 변경시킨 모든 Event의 순서를 저장하는 패턴.

## 기존 방식 vs 이벤트 소싱
기존 방식
흔히 CRUD를 이용하여 과거 값을 업데이트 한다.
- 상황: 사용자 A가 주소를 '서울'에서 '부산'으로 변경
- DB 동작: UPDATE users SET address = '부산' WHERE id = 'A';
- 결과: DB에 '부산'만 남게 된다.

이벤트 소싱
INSERT (Append-only)만 한다.
- 상황: 사용자 A가 주소를 '서울'에서 '부산'으로 변경
- DB 동작:
  - INSERT event (type='UserCreated', address='서울', time=...)
  - INSERT event (type='AddressChanged', address='부산', time=...)
- 결과: 두 개의 이벤트가 모두 남는다

## 왜 사용하는가?
1. Audit Log: 데이터 자체가 로그이므로, 부정 행위 추적이나 법적 증거 필요한 시스템에 사용
2. 타임 머신: 특정 시점까지의 이벤트만 재생하면되기에 특정 시점의 상태 확인 가능
3. DDD와의 궁합: 비즈니스 로직 자체가 이벤트 흐르믕로 표현되므로, 비즈니스 언어와 코드의 갭이 줄어듬

## 단점
1. 성능
만약 10년 치 입출금 내역을 처음부터 다 더해야 하는 경우에 엄청 느려진다.
해결책: 스냅샷을 통해 특정 시점의 중간 합계를 별도로 저장하여, 조회 시 가장 최근 스냅샷을 이용하여 계산한다.

2. 조회의 어려움
"가입한 지 1년 넘었고, 서울에 사는 사람 다 찾아줘" 같은 쿼리를 날릴 경우, 이벤트가 JSON으로 묶여 있어 WHERE 절 쓰기가 어려움.
해결책: CQRS 패턴을 사용한다. 만약 이벤트가 저장되면, 이벤트를 구독해서 조회용 RDB에 별도로 데이터를 가공하여 넣어놓는다. 그러면 빠르게 검색이 가능하다.

