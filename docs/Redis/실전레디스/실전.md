# 5. 레디스 운용 관리
## 5.1 데이터 영속성
Redis가 재시작되어 데이터가 유실돼도, RDBMS로 부터 캐시를 다시 복구할 수 있다. 그러나 이 과정에서 캐시 미스로 인해 성능에 영향을 미친다.

레디스에선 영속성 관련 기능을 제공하지만, 모두 활성화하는 것을 권장하지 않는다.
성능과 내구성의 타협점을 찾고 그에 맞춰 설정해야 한다.

**[영속성 보장 방법]**
1. 스냅샷
2. AOF

**[영속성 전략]**
- 스냅샷
- AOF
- 스냅샷 + AOF
- 영속성 사용 안함

기본적으로 AOF는 비활성화, 스냅샷은 다음 조건이 기본값으로 설정됨.
- 1시간 내에 최소 하나 이상의 키가 변겨오디는 경우
- 5분 내에 최소 100개 이상의 키가 변경되는 경우
- 1분 내에 최소 10,000개 이상의 키가 변경되는 경우

### 5.1.1 스냅샷
특정 시점의 DB 내 내용을 RDB라는 형식의 파일(Redis DataBase)으로 저장.
- 수동: SAVE 명령어(동기) 혹은 BGSAVE 명령어(비동기) 

레디스는 기본적으로 싱글 스레드로 요청을 처리하므로 SAVE 명령어는 동일한 스레드 내에 RDB 파일 생성
그러나 이 동작은 Dump 중에 다른 요청을 차단하므로 실제 운영환경에서 권장 X

**[BGSAVE 명령어 작동 과정]**
1. 요청 처리 중인 프로세스에 RDB 덤프를 위해 fork
2. 자식 프로세스가 데이터 셋 전체를 임시 RDB 파일로 덤프
3. 덤프 완료되면 설정된 RDB 파일 이름으로 변경


**[BGSAVE 명령어 사용 시 확인 사항]**
1. 스냅샷을 위한 메모리가 충분한가
2. 문제없이 레플리카에서 스냅샷을 가져올 수 있는가
3. 서비스에 지장 없는 시간에 스냅샷을 생성하는가

### 5.1.2 AOF
레디스 서버에 문제가 생기면, 마지막 스냅샷 이후 데이터는 손실된다.
반면 AOF는 거의 실시간 백업 처럼 작성 중인 파일 끝에 계속 추가하여 기록하기에 내구성이 높음.
대신 스냅샷 RDB 파일보다 크기가 커진다.
또한, AOF 파일 명령어 내용을 다시 재생하여 메모리 적재하는 형식이므로, 재시작 시간이 길어짐

AOF는 fsync로 디스크에 쓰기 작업을 하므로 appendfsync 지시자 설정으로 자동 생성 시점 설정 가능
- always: 쓰기 작업마다 버퍼에서 디스크로 flush
- everysec:pthread에서 백그라운드 스레드를 생성하여 매초마다 버퍼에서 디스크로 flush
- no: OS가 설정한 적절한 시점에 실행

#### AOF 매커니즘
1. 요청 처리 중인 프로세스에서 AOF를 재작성하기 위해 자식 프로세스를 fork
2. 자식 프로세스는 새로운 AOF 파일을 생성한 후 재작성 결과 저장
3. 자식 프로세스가 새로운 AOF 파일 재작성 완료하면 부모 프로세스에 신호를 보냄
4. 신호 받은 부모 프로세스는 fork 이후의 쓰기 작업 내용을 AOF 재작성 버퍼에 저장해두었다가, 자식 프로세스에 전송. 자식프로세스는 변경된 내용을 AOF 파일에 반영
5. 오래된 AOF 파일을 새 AOF 파일로 교체

### 5.1.3 스냅샷과 AOF 비교
- 스냅샷 사용 시
  - 장점
    - 특정 시점의 상태를 덤프하며 파일 크기가 작음
    - 자식 프로세스의 Fork 처리 시에만 성능에 영향을 미침. 나머지 처리는 백그라운드로 수행되어 영향이 작음
    - AOF보다 빠르게 시작 가능
  - 단점
    - 문제 발생 시, 이전 스냅샷 이후의 데이터가 손실되어 내구성이 AOF보다 낮음
- AOF
  - 장점
    - 데이터 내구성이 높음
  - 단점
    - 트랜잭션 로그를 REDO 로그 형태로 기록하며, 실제 데이터를 기록하지 않기에 같은데이터 셋이라도 AOF 파일 크기가 커질 수 있음
    - 스냅샷보다 성능 저하에 미치는 것이 큼
    - 레디스 서버 시작할 때 파일 로딩이 오래 걸림

### 5.1.4 데이터 삭제 패턴
레디스를 운용하면서 갑자기 데이터가 사라지는 경우가 종종 발생한다.
즉, 레디스 내구성을 고려하면서도 내부적으로 어떻게 데이터를 삭제하는지도 알아두어야 한다.

**[손실 상황]**
- 엔진 재시작
- 레디스 서버 전체 장애
- 명령어 실행
  - DEL/HDEL/XDEL 명령어
  - FLUSHALL/FLUSHDB 명령어
  - UNLINK 명령어
- TTL 만료
  - EXPIRE/EXPIREAT/PEXPIRE/PEXPIREAT 명령어
  - SET 명령어의 EX 옵션
- 강제 제거
- 비동기 레플리케이션
- 레디스 클러스터의 네트워크 단절
- 기타
  - 키 이름 재설정(RENAME 명령어로 이름을 변경한 후 예전 키 이름을 지정하는 경우)
  - 잘못된 DB 선택
  - 데이터가 아예 삽입되지 않은 경우

## 5.2 캐시 서버로서 레디스 아키텍처

### 5.2.1 읽기 관점 아키텍처
#### 지연 로딩 패턴
> 캐시 히트면 캐시에서, 캐시 미스면 DB에서 가져오고 캐시 최신화

1. 애플리케이션은 레디스에 데이터를 요청
2. 요청된 데이터가 레디스 서버에 존재하는지, 유효 기간 내인지에 따라 처리 내용 분기
   1. 요청된 데이터가 레디스 서버에 존재하거나 유효 기간 내라면, 레디스에서 애플리케이션으로 응답
   2. 요청된 데이터가 레디스 서버에 미존재하거나 유효 기간이 지난 경우,
      1. 애플리케이션이 백엔드 데이터베이스에서 데이터를 가져옴
      2. 애플리케이션은 가져온 데이터를 레디스 캐시에 업데이트

- **장점**
  - 레디스 캐시 노드 장애 시 다운타임을 줄여 지연 시간 영향을 최소화
  - 요청된 데이터만 캐시에 저장하므로 쾌적
- **단점**
  - 가져온 데이터가 오래되었을 수 잇음
  - 캐시 미스 시 오버헤드가 큼

#### Read-Through 패턴

> 지연 읽기 쓰기 패턴 변형 : DB에서 읽어오는 작업을 애플리케이션 대신 라이브러리를 사용

### 5.2.2 쓰기 관점 아키텍처

