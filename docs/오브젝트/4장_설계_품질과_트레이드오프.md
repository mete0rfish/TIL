pu객체지향 설계란 올바른 객체에서 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동.
1. 객체지향 설계의 핵심이 책임
2. 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다

객체를 데이터 위주로 생각할 경우, 퍼블릭 인터페이스에 노출되어 OCP에 위반된다.

# 1. 데이터 중심의 영화 예매 시스템
![4-1](image-10.png)

# 2. 설계 트레이드오프
### 캡슐화
상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다.
이를 통해 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다.

> 변경될 가능성이 높은 부분을 `구현`, 상대적으로 안정적인 부분을 `인터페이스`라고 부른다.

### 응집도와 결합도
> 응집도: 모듈에 포함된 내부 요소들이 연관돼 있는 정도
> 결합도: 의존성 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는가

응집도가 낮을 경우, 변경해야 하는 부분이 다수 모듈로 분산돼어 수정이 복잡해짐.
![4-2](image-11.png)

# 3. 데이터 중심의 영화 예매 시스템의 문제점
- 대표적인 문제점
  - 캡슐화 위반
  - 높은 결합도
  - 낮은 응집도

### 캡슐화 위반
```java
public class Movie {
    private Money fee;

    public Money getFee() {
        return fee;
    }

    public void setFee(Money fee) {
        this.fee = fee;
    }
}
```
- getFee()와 setFee()는 Movie 내부에 Money 타입의 fee를 사용하기에 퍼블릭 인터페이스에 노골적으로 드러난다.

### 높은 결합도
```java
public class ReservationAgency {
    public Reservation reserve(...) {
        Money fee;
        if (discountable) {
            ...
            fee = movie.getFee().minus(discountAmount).times(audienceCount);
        } else {
            fee = movie.getFee();
        }
    }
}
```
- ReservationAgency에서 한 명의 예매 요금을 계산하기 위해 Movie의 getFee()를 통해 가져와 사용한다.
- 만약 fee의 타입이 바뀌면 ReservationAgency까지 수정해야 한다.

### 낮은 응집도
만약 아래 처럼 여러 시나리오가 추가될 경우, ReservationAgency는 수정해야한다.
- 할인 정책이 추가될 경우
- 할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우
- 할인 조건이 추가되는 경우
- 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
- 예매 요금을 계산하는 방법이 변경될 경우

모듈의 응집도를 높이기 위해 SRP(단일 책임 원칙)을 강조한다.

# 4. 자율적인 객체를 향해
### 캡슐화를 지켜라
객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.
스스의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.

```java
class Rectangle {
    private int left;
    private int top;
    private int right;
    private int bottom;

    // getter
    // setter
}

class AnyClass {
    void anyMethod(Rectangle rectangle, int multiple) {
        rectangle.setRight(rectangle.getRight() * multiple);
        rectangle.setBottom(rectangle.getBottom() * multiple);
    }
}
```

- 문제점
  - 코드 중복 발생
  - 변경에 취약

### 스스로 자신의 데이터를 책임지는 객체
- 이 객체가 어떤 데이터를 포함해야 하는가?
  - 이 객체가 어떤 데이터를 포함해야 하는가?
  - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

# 5. 하지만 여전히 부족하다.
### 캡슐화 위반
```java
public class DiscountCondition {
    private DiscountConditionType type;
    private int sequence;
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;
    public DiscountConditionType getType() { ... }
    public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) { ... }
    public boolean isDiscountable(int sequence) { ... }}
```

DiscountCondition 객체 내부에 DayOfWeek과 LocalTime 인스턴스 변수로 포함된 사실이 인터페이스를 통해 외부에 노출되고 있다.
도한, isDiscountable(int sequence) 역시 객체가 int 타입의 순번 정보를 포함하고 있음을 외부에 노출한다.

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondition> discountConditions;
    private MovieType movieType;
    private Money discountAmount;
    private double discountPercent;

    public MovieType getMovieType() { ... }
    public Money calculateAmountDiscountedFee() { ... }
    public Money calculatePercentDiscountedFee() { ... }
    public Money calculateNoneDiscountedFee() { ... }}
```

Movie 클래스는 파라미터 대신 메서드 명 (AmountDiscountaedFee, ...)으로 할인 정책이 드러나고 있다.

### 높은 결합도
```java
public class Movie{

    public boolean isDiscountable(LocalDateTime whenScreened, int sequence) {
        for (DiscountCondition condition : discountConditions) {
            if (condition.getType() == DiscountConditionType.PERIOD) {
                if (condition.isDiscountable(whenScreened.getDayOfWeek(), whenScreened.toLocalDate())) {
                    return true;
                }
            } else {
                if (condition.isDiscountable(sequence)) {
                    return true;
                }
            }
        }

        return false;
    }
}
```
Movie와 DiscountCondition 사이의 결합도가 미치는 영향
- DiscountCondition의 기간 할인 조건 명칭이 PERIOD에서 다른 값으로 변경 시, Movie 수정
- DiscountCondition의 종류가 추가되거나 삭제되면 Movie 안의 if-else 구문 수정 필요
- 각 DiscountCondition의 만족 여부를 판단하는 정보가 변경되면, Movie의 isDiscountable 메서드로 전달된 파라미터 변경 필요.

### 낮은 응집도
```java
public class Screening {

    public Money calculateFee(int audienceCount) {
        switch (movie.getMovieType()) {
            case AMOUNT_DISCOUNT:
                if (movie.isDiscountable(whenScreened, sequence)) {
                    return movie.calculateAmountDiscountedFee();
                }
                break;
            case PERCENT_DISCOUNT:
                if (movie.isDiscountable(whenScreened, sequence)) {
                    return movie.calculatePercentDiscountedFee();
                }
            case NONE_DISCOUNT:
                return movie.calculateAmountDiscountedFee().times(audienceCount);
        }

        return movie.calculateNoneDiscountedFee().times(audienceCount);
    }
}
```
할인 조건 종류가 변경되면 DiscountCondition, Movie, Screening 모두 변경 필요.
하나의 변경을 수용하기 위해 코드 여러 곳을 동시에 변경해야 한다는 설계의 응집도가 낮음.

# 6. 데이터 중심 설계의 문제점
- 데이터 중심 설계가 변경에 취약한 이유
  - 데이터 중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
  - 데이터 중심 설계에서 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채오퍼레이션을 결정한다.

