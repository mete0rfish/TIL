# 개요
Open Session In View의 약자로, 영속성 컨텍스트를 뷰 렌더링이 끝날 대까지 열어두는 설정을 의미.

- 과거
원래 JPA에서 영속성 컨텍스트 생존 범위는 Transaction의 범위와 같다. 즉, 서비스 계층에서 트랜잭션이 끝나면 영속성 컨텍스트도 닫히고, DBCP도 반환.

- 문제점
- Transaction이 끝난 후, 컨트롤러나 뷰에서 Lazy Loading을 시도하면, 이미 영속성 컨텍스트가 닫혀서 LazyInitializationException 예외가 발생.

- 해결책
Transaction이 끝나도, 클라이언트에게 응답을 보낼 때까지 영속성 컨텍스트를 살려두는 방식

# 원리
기존적으로 `spring.jpa.open-in-view: true`로 설정됨.

1. 요청 시작: 요청이 들어오면 서블릿 필터나 인터셉터에서 영속성 컨텍스트 생성 및 DB 커넥션 획득
2. 트랜잭션 시작: 서비스 계층에서 @Transactional 시작
3. 서비스 로직 수행
4. 트랜잭션 종료: 트랜잭션 커밋되지만, 영속성 컨텍스트와 DB 커넥션은 닫지 않고 유지
5. 컨트롤러/뷰: 컨트롤러에서 지연 로딩을 통해 연관된 엔티티 조회해도, 영속성 컨텍스트가 살아있어 정상적으로 데이터 가져옴.
6. 응답 완료: 클라이언트에게 API 응답이 전송되 후에 영속성 컨텍스트를 종료 및 DB 커넥션 반환

## 장점
- LazyInitializationException 방지
- 코드의 간결함: 뷰에 데이터 넘겨줄 때, 서비스 계츠에서 미리 데이터를 다 로딩해서 DTO로 변환하는 작업 필요없음. 엔티티 그대로 컨트롤러로 반환해도 가능

## 단점
DB 커넥션 리소스 낭비
- 커넥션 점유 시간 증가: 영속성 컨텍스트가 살아있는 동안 커넥션을 붙잡고 있기 때문
- 장애 시나리오
  - 컨트롤러에서 외부 API를 호출하거나 복잡한 연산 수행으로 응답이 1초 지연될 경우
  - OSIV가 켜져 있으면, 그 1초동안 아무런 DB 작업도 안하면서 DB 커넥션을 계속 점유
  - 트랜픽이 몰리면 DBCP가 금방 고갈되어, DB 작업이 대기

# 켜야할까? 꺼야할까?
## 시나리오 A: 고객 서비스 - OFF
트래픽이 많고 성능이 중요한 API 서버에선 끄는 것을 권장

- 컨트롤러 지연 로딩 해결 방법
  - Fetch Join
  - DTO 변환: 서비스 계층에서 엔티티를 DTO로 모두 변환하여 컨트롤러에 반환
  - Facade 패턴: 조회 전용 서비스를 별도로 제작

## 시나리오 B: 어드민 시스템 - ON
트래픽이 적고, 개발 속도가 중요한 관리자 시스템에선 키는 것을 권장

- 복잡한 뷰 렌더링을 위해 데이터 로딩을 매번 최적화하는 비용보다 개발 편의성이 더 가치가 크기 땨ㅐ문.

# Command와 Query의 분리
OSIV를 끄면서 복잡성을 관리하는 방법은 CQS 패턴을 사용하는 방법이다.

- Command Service: 데이터 등록/수정/삭제 서비스. 엔티티를 다루며 트랜잭션 안에서 처리
- Query Service: 화면이나 API에 맞춘 조회 전용 서비스. @Transactional(readOnly = true)를 걸고, 필요한 데이터를 DTO로 변환해서 컨트롤러에 넘김.