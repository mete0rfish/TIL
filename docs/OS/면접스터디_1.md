# 질문과 답
### 1. 프로그램 실행 중 인터럽트 발생 및 처리과정
```
인터럽트 발생 시, CPU는 현재 작업의 프로그램 카운터와 레지스터 값을 스택에 저장한다.
인터럽트 서비스 루틴으로 이동하여 인터럽트를 처리 후, 저장한 값을 복원해 원래 작업으로 돌아간다.
```

### 2. 폴링 방식과 인터럽트 방식의 차이점
```
폴링 : CPU에서 특정 이벤트가 발생하는지 계속 확인하는 방식
- CPU 리소스 소모
인터럽트 : 이벤트 발생 시, CPU에게 알림을 보내는 방식
- 실시간 대응 시 유리
```

### 3. MMU 없는 경우의 문제점. base와 limit 레지스터를 이용한 보호 방법.
```
MMU는 가상 메모리의 논리 주소를 실제 데이터의 물리 주소로 변화하는 역할을 수행한다.
만약 MMU가 없으면 정확한 물리 주소를 프로그래머가 알아야하며, 잘못된 주소로 데이터 손상을 일으킬 수 있다.
MMU는 메모리를 보호하기 위해 base 레지스터에 물리 주소의 시작 주소를 저장하고, limit 레지스터의 프로세스 사이즈를 저장한다.
 이 레지스터는 커널 모드에서만 수정하도록 하여, 무분별한 접근을 막는다.
```

### 4. 페이지 폴트 발생 시, 페이지 교체를 통해 문제를 해결하는 방법
```
물리 주소를 통해 메모리에 접근했지만 페이지가 적재되어 있지 않는 페이지 폴트 발생 시, 아래 과정을 거친다.

1. 페이지 테이블을 통해 페이지가 메모리에 있는지 확인
2-1. 메모리에 없는 경우(페이지 폴트), 희생 프레임 선택
2-2. 스왑영역에서 페이지 교체
3. 페이지 테이블 업데이트 

과할당을 통해 페이지가 메모리에 적재되지 않는 경우, 사용자에게 메모리 부족을 노출시키지 않음으로써 쾌적한 사용자 경험을 제공한다.
```

### 5. 캐시 메모리가 CPU 성능에 미치는 영향
```
CPU와 메모리의 처리 속도 차를 극복하기 위해 캐시 메모리를 사용한다.
캐시 메모리에 hit률이 높을 수록 메모리에 접근하는 시간을 줄일 수 있기 때문에 캐시에 필요한 정보를 저장하는 것이 시간 지연을 낮출 수 있다.
시간 지역성은 최근 참조된 데이터가 가까운 미래에 다시 참조될 가능성을, 공간 지역성은 최근 참조된 데이터의 주변 데이터가 참조될 가능성을 말한다.
이런 지역성을 이용하여 캐시 hit를 높일 수 있다.
```

### 6. 메모리 관리 기법의 종류와 주요 기법
```
연속/불연속: 프로그램을 통으로 메모리 할당 / 프로그램을 특정 단위로 나눠 할당
고정/동적: 고정된 크기로 나눔(내부 단편화) / 필요한 크기 할당(외부 단편화)

페이징 : 고정 크기의 페이지와 프레임 -> 내부 단편화
세그먼테이션: 가변 크기세그먼트로 할당 -> 외부 단편화

```

### 7. PCB는 무엇이고, PCB가 없을 경우 발생하는 문제
```
PCB는 각 프로세스의 메타데이터를 저장하는 구조체다.
CPU는 한 번에 하나의 프로세스만 구동 시킬 수 있기 때문에 여러 프로그램을 작동시키기 위해 컨텍스트 스위칭이라는 과정이 필요하다.
만약 A라는 프로세스를 구동하다 B라는 프로세스를 구동시킨다고 가정했을 때, B 종료 후에 A로 회귀하기 위해선 A의 상태와 레지스터 값 등을 가지고 있어야 한다.
이런 메타데이터를 PCB에 저장하여 관리한다.
```

### 8. 컨텍스트 스위칭란 무엇인가
```
멀티 프로세스 환경에서 CPU가 프로세스의 상태를 저장하고 로드시키는 과정을 의미한다. 
타임 슬라이스가 만료되었거나 IO 작업, 다른 프로세스의 리소스를 기다려야 하는 경우 발생한다.
```

### 9. 프로세스와 쓰레드의 차이
```
프로세스는 실행 중인 프로그램을 말하며, 독립된 메모리 영역을 가지고 있어 다른 프로세스와 자원을 공유하지 않는다.
쓰레드는 프로세스 내에 동시에 진행되는 작업들을 의미하며, 독립된 Stack을 제외한 나머지 메모리 영역을 쓰레드들이 함께 공유한다.
```

### 10. 페이지 교체 알고리즘
```
최적 교체: 가장 먼 미래에 사용될 페이지 선택 (이론상)
FIFO: 가장 오래전에 적재된 페이지 선택
LRU: 가장 오래전에 적재된 페이지 선택
Clock: FIFO + LRU
```

### 11. 프로세스 상태
```
Ready : CPU 할당받지 못해서 CPU 스케줄링되길 기다리는 상태

Running : CPU에 의해 실행 중인 상태로, 타임슬라이스가 끝나면 Ready 상태로 바뀌고 IO발생 시, Blocked 상태가 되어 대기 큐에 삽입됨

Waiting/Blocked : 프로세스가 자원을 요청하거나, IO 요청되어 기다리는 상태로, 목적을 이루면 Ready 상태가 되어 스케쥴링을 기다린다.

Terminated : 프로세스가 모든 작업을 마친 상태. 프로세스 테이블의 항목과 PCB가 완전히 삭제된 상태.
```

***
# 추가 질문
### 프로세스가 불완전 종료될 경우, 어떻게 되는가?
```
부모가 wait를 통해 자식 프로세스의 종료를 확인하지 않고 종료를 하게되면 자식 프로세스는 좀비 프로세스가 된다.
리눅스 기준으로 init 프로세스에게 입양된다. 프로세스 테이블의 항목과 PCB가 여전히 남아있다.
```

### 자식 프로세스를 만드는 이유
```
자식 프로세스와 부모 프로세스를 나누어 실행하므로서 병렬처리가 가능하고 작업효율을 높일 수 있다.
예를 들어 웹서버에서 프로세스는 사용자마다 자식 프로세스를 만들어 사용자의 요청을 처리하기에 다중 접속이 가능하다.
```

### 실행 단위로서의 프로세스의 문제점
```
1. PCB 생성, 매핑 테이블 생성 등 오버헤드가 큼
2. 프로세스 컨텍스트 스위칭 시, PCB 교체 및 캐시를 다시 채우는 등 오버헤드가 큼
3. 프로세스 사이의 자원이 독립적이어서 서로 통신하기 어려움
```

### 프레임 수와 페이지 폴트가 관련이 있을까?
```
프레임 수가 많을 수록 메모리에 적재할 페이지 개수또한 많아지기 때문에 원하는 작업이 메모리에 적재되어 있을 확률이 늘어 페이지 폴드가 적게 발생할 수 있다.
```