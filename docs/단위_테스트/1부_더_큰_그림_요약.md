# 1. 단위 테스트의 목표
## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표
### 1.3.1 코드 커버리지 지표에 대한 이해

> 코드 커버리지 = 제품 코드 라인 수 / 전체 라인 수

코드 커버리지는 단순히 위 공식에 따라 계산된다. 이를 다르게 생각하면 충분히 코드 커버리지 조작이 가능하다는 것이다.

```java
public static boolean isStringLong(String input) {
    if(input.length > 5)
        return true;
    return false;
}

@Test
void test() {
    boolean result = isStringLong("abc");
    assertThat(result).isEqualTo(false);
}
```

위 테스트의 경우, return 문을 제외한 모든 코드를 반영하기 때문에 80%의 코드 커버리지를 가진다. 그러나 이를 삼항 연산자를 통해 100%의 코드 커버리지로 손쉽게 조작이 가능하다.
이는 코드 커버리지가 테스트 스위트 개선에 기여하지 않는 예시를 보여준다.

### 1.3.2 분기 커버리지 지표

> 분기 커버리지 = 통과 분기 / 전체 분기 수

if나 switch 문과 같은 제어 구조에 중점을 둔다. 따라서 코드 커버리지보다 더 정확한 결과를 가져올 수 있다.

### 1.3.3 커버리지 지표에 관한 문제점

<br/>

# 2. 단위 테스트란 무엇인가

## 2.1 단위 테스트의 정의

단위 테스트에서의 가장 중요한 세 가지 속성

1. 작은 코드 조각을 검증하고
2. 빠르게 수행하고
3. 격리된 방식으로 처리하는 자동화된 테스트다

### 2.1.1 격리 문제에 대한 런던파의 접근

테스트 대상 시스템을 협력자에게서 격리 시켜야한다고 주장한다. 즉, 하나의 클래스가 다른 클래스를 의존하면 테스트 대역으로 대체해야 한다는 것이다. 이를 통해 테스트 대상 클래스에만 집중이 가능하다.

### 2.1.2 격리 문제에 대한 고전파의 접근
테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다는 뜻을 의미한다.
예를 들어, 어떤 테스트에선 DB에서 고객을 생성하지만 어떤 테스트에선 DB에서 고객을 삭제할 수도 있어 모두 테스트가 정상적으로 작동하지 않을 수 있다.

> 공유 의존성 : 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성 (예, DB)
> 
> 비공개 의존성 : 공유하지 않는 의존성
>
> 프로세스 외부 의존성 : 실행 중인 프로세스 외부에서 실행되는 의존성

공유 의존성은 단위 테스트간 공유되는 싱글턴 의존성이다.(예, 설정 파일)

공유 의존성을 대체하는 이유는 테스트 실행 속도를 높이기 위해서이다. 다시 말해 단위가 반드시 클래스에 국한될 필요는 없다. **공유 의존성이 없는 한 여러 클래스를 묶어서 단위 테스트할 수 있다.**

## 2.2 단위 테스트의 런던파와 고전파

|  | 격리 주체 | 단위의 크기 | 테스트 대역 사용 대상 |
| --- | ----- | ----- | ----- |
| 런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성 |

### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

런던파는 불변 객체는 교체하지 않고 그대로 사용한다. 예를 들어 ENUM이나 상수 또는 값 객체의 경우 어떤 인스턴스를 넣더라도 결과가 동일하기 때문이다. 

프로세스 외부 의존성을 공유하려면 단위 테스트가 서로 통신할 수 있는 수단이 있어야 한다. 그런 의미에서 프로세스 외부의 불변 의존성은 그런 수단을 제공하지 않기 때문에 실행 컨텍스트에 영향을 주지 않는다.

## 2.3 고전파와 런던파의 비교

**[ 런던파의 이점 ]** 
- 입자성이 좋고, 테스트가 세밀하다.
- 연결된 클래스가 많아져도 테스트가 용이하다.
- 테스트 실패 시, 어떤 기능이 실패했는지 확실히 알 수 있다. 의존성들을 모두 제거했기 때문

### 2.3.1 힌 번에 한 클래스만 테스트하기

> 테스트는 코드의 단위를 검증해선 안된다. 동작의 단위(문제 영역에 의미 있는 것)로 검증되어야 한다. 단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수도, 아주 작은 메서드가 될 수도 있다.

'우리집 강아지를 부르면, 바로 나에게 온다'

'우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다.'

두번째 이야기는 어떤 동작을 하는 것인지 의미를 알 수 없다. 테스트 또한 마찬가지로 작성되어야 한다.

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
테스트 대역을 통해 클래스의 직접적인 의존성을 대체해 그래프를 나눌 수 있어, 단위 테스트의 준비해야할 작업량을 크게 줄여준다. 그러나 **대개 클래스 그래프가 커진 것은 설계 문제의 결과**이다. Mock은 이런 문제를 감출뿐 해결해주진 않는다는 것을 명심해야 한다.

<br/>

# 3. 단위 테스트 구조
## 3.1 단위 테스트를 구성하는 방법
### 3.1.1 AAA 패턴 사용
준비, 실행, 검증 패턴을 통해 테스트를 읽기 쉽게 만들 수 있다. 우리가 흔히 사용하는 Given-When-Then 패턴과 차이가 없다. 

### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기
만약 각 구절이 여러 개일 경우 이는 단위 테스트가 아니라 통합 테스트가 된다. 통합 테스트는 실행 구절을 여러 개 두어도 문제가 되지 않는다. 또한 통합 테스트에선 속도를 높이기 위해 여러 테스트를 묶어서 수행할 수도 있다.

### 3.1.3 테스트 내 if 문 피하기
테스트는 분기가 없는 간단한 일련의 단계여야 한다. 이는 통합 테스트에서도 예외가 없다. 이는 추가 유지비만 불리는 원인이 된다.

### 3.1.4 각 구절은 얼마나 커야 하는가?

- 준비 구절은 가장 크며 실행과 검증을 합친 만큼 클 수 있다. 코드 재사용을 위해 `오브젝트 마더`나 `테스트 데이터 빌더` 패턴을 적용할 수 있다.
- 실행 구절은 보통 한 줄이다. 이 이상을 넘어가면 불변을 위반하고 캡슐화가 적용되어 있지 않은 것이다.

### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가
단일 동작 단위에 맞게 작성되는 것이 좋다. 그러나 검증 구절이 너무 커지는 것은 경계해야 한다. 클래스 내의 동등 멤버를 정희하여 단일 검증문으로 적용이 가능하다.

### 3.1.6 종료 단계는 어떤가?
AAA 패턴에는 포함되지 않는다. 종료는 통합 테스트의 영역이다.

### 3.1.7 테스트 대상 시스템 구별하기
SUT와 의존성을 구분하는 것이 좋다. 따라서, 인스턴스 명을 sut로 변경하여 사용하는 것도 좋은 사례이다.
```c#
public class CalculatorTests
{
    [Fact]
    public void Sum_of_two_numbers()
    {
        // 준비
        double first = 10;
        double second = 20;
        var sut = new Calculator();

        // 실행
        double result = sut.Sum(first, second);

        // 검증
        Assert.Equal(30, result);
    }
}
```

### 3.1.8 준비, 실행, 검증 주석 제거하기
주석 대신 빈 줄로 구절을 구분하여 간결성과 가독성 사이에서 균형을 잡을 수 있다. 그러나 대규모 테스트에선 가독성을 위한 주석 유지가 필요하다.


## 3.2 xUnit 테스트 프레임워크 살펴보기

## 3.3 테스트 간 테스트 픽스처 재사용
> 테스트 픽스처는 테스트 실행 대상 객체로, SUT로 전다로디는 인수이다. 이 객체는 테스트 실행 전 고정 상태로 유지하기에 동일한 결과를 생성한다.

### 3.3.1 테스트 간의 높은 결합도는 안티 패턴

```java
class CustomerTests {
    private Store _store;
    private Customer _sut;

    public CustomerTests() {
        _store = new Store();
        _store.addInventory(Product.Shampoo, 10);
        _sut = new Customer();
    }
    
    @Test

    @Test
}
```

이는 테스트 간에 영향을 주기 때문에 테스트의 독립적인 실행을 반영해주지 않는다.

### 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용
테스트 클래스에 생성자가 길어질 경우, 테스트에 대한 가독성이 매우 떨어지게 된다.

### 3.3.3 더 나은 테스트 픽스처 재사용법
private 팩토리 메서드를 두어 사용하는 것이 하나의 방법이 될 수 있다.

```java
class CustomerTests {
    private Store _store;
    private Customer _sut;
    
    @Test

    @Test

    private Store createStoreWithInventory(Product product, int quantity) {
        Store store = new Store();
        store.setInventory(productm quantity);
        return store;
    }

    private static Customer createCustomer() {
        return new Customer();
    }
}
```

준비 로직이 매우 길어질 경우 팩토리 메서드를 만들어 사용할 수 있다.

## 3.4 단위 테스트 명명법
첫번째 관습은 `[테스트 대상 메서드]_[시나리오]_[예상결과]`를 이용하는 것이다.
그러나 이 명명법에는 문제가 존재한다. 메서드 이름을 포함하는 순간 테스트가 SUT 메서드에 의존하게 되기 때문에 유지 보수성이 떨어진다. 그리고 테스트 단위를 동작이 아닌 메서드 단위로 바라보게 된다.

따라서 상황 위주의 메서드 명을 짓는 것이 더 도움이 될 수 있다.

> public void Delivery_with_a_past_date_is_invalid()

## 3.5 매개변수화된 테스트 리팩터링하기
과거 날짜에 대해서 예외가 발생하는 테스트 코드를 작성한다고 가정해보자. 1일 전, 1달 전, 1년 전 등 모든 케이스에 대해서 테스트 코드를 작성하는 것은 매우 비효율적이다.

### 3.5.1 매개변수화된 테스트를 위한 데이터 생성

```java
private static Stream<LocalDateTime> dateTimeProvider() {
        return Stream.of(
            LocalDateTime.of(2022, 5, 5, 10, 15, 30, 0),
            LocalDateTime.of(2023, 1, 1, 0, 0, 0, 0),
            LocalDateTime.of(2025, 12, 31, 23, 59, 59, 999999999)
        );
}

@ParameterizedTest
@MethodSource("dateTimeProvider")
void shouldTestLocalDateTimeConversion(LocalDateTime dateTime) {
    LocalDateTime inputDateTime = dateTime;

    LocalDateTime convertedDateTime = inputDateTime.toLocalDate().atStartOfDay();

    assertThat(convertedDateTime.toLocalDate().getYear()).isEqualTo(inputDateTime.getYear());
}
```

Java 진영에선 Junit5에서 제공하는 `@ParameterizedTest`를 활용하여 간편하게 사용이 가능하다.

## 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상
