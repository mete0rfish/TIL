# 12. 자동 테스트
QA 팀이나 사람을 통해 이루어지는 수동 테스트만으로 인수 테스트가 진행될 경우 매우 많은 비용이 들게 되어 조직 전체의 퍼포먼스가 떨어지고, 이는 품질 저하로 이어진다. 자동 테스트를 통해 테스트의 성공 실패 여부 뿐만 아니라 커버리지 또한 확인이 가능하다.이는 개발자의 부담을 줄여주는 방향으로 누적된다.

## 12.1. Regression
`Regression`은 시스템에서 정상적으로 제공하던 기능이 어떤 배포 시점을 기준으로 제대로 동작하지 않게 되는 상황을 말한다. 이런 회귀 버그 문제를 해결하기 위해 테스트르 이용하여 공통 코드가 초기 개발 의도를 지키고 있는지 능동적으로 감시해야 한다.

만약 새로운 팀원이 합류하게 되면 해당 팀원은 자신의 코드가 서비스에 영향을 주는지 걱정을 하게 된다. 이런 문제는 프로젝트를 키우거나 조직을 확장하는데 큰 걸림돌이 된다. 이는 자연스럽게 신규 입사자의 온보딩을 점점 느리게 만든다.

이런 문제를 해결하기 위해 자동화된 회귀 테스트를 진행한다. 회귀 테스트가 가급적 자동으로 이어져야 매우 효율적으로 처리가 가능하다.

> 코드 커버리지는 100%가 아니여도 회귀 테스트 효과를 누릴 수 있다.

## 12.2. 의도
우리는 타인이 작성한 코드에서 의도를 어떻게 파악할 수 있을까? 만약 퇴사자가 작성한 코드의 경우 물어볼 방법도 없다. 또한 코드리뷰로도 한계가 명확하다. 테스트 코드는 개발자의 의도를 나타낼 수 있는 좋은 수단이다.

### 테스트 코드의 의도 예시
```java
public void doSomething(long userId) {
    userRepository.getById(userId);

    // 생략
}
```

메서드 상에선 getById()의 반환 값을 사용하지도 않고 왜 있는지 알 수 없다. 이는 사실 getById()의 예외가 발생하는지 알기 위해 추가된 코드로, 주석 및 메서드명을 통해 개발자의 의도를 나타내지 않았다. 그러나 이를 테스트 코드에선 의도를 나타낼 수 있다.

```java
public class SampleTest {

    @Test
    void doSomething_호출시_유저가_없으면_에러를_던진다() {
        // given        
        long userId = 1L;       
        
        // when        
        // then        
        assertThatThrownBy(() -> {
            userService.doSomething(userId); 
        }).isInstanceOf(ResourceNotFoundException.class);
    }
}
```
TDD라ㄴ 개발자가 실제 코드를 작성하기 전에 해당 코드의 테스트 케이스를 먼저 작성하게 하는 개발 방법론이다. 즉, 테트는 개발자의 의도를 드러내는 방법이다.

물론 메서드 명을 토애서도 의도를 나타낼 수 있지만, 테스트를 통해 책임을 드러내는 수단으로 바라볼 수 있게 한다. 

## 12.3. 레거시 코드
> 레거시 코드란 단순히 테스트 루틴이 없는 코드다.

우리가 소위 말하는 레거시 코드는 옛날에 만들어지고, 최신 트랜드를 반영하지 않은 코드를 말한다. 그러나 레거시 코드를 우리가 싫어하는 이유는 코드를 이해할 수 없기 때문이다. 따라서 레거시 코드는 단순히 오래된 코드가 아니라 테스트 루틴이 없어 이해할 수 없는 코드를 말하는 것이다.

<br/>

# 13. 테스트 피라미드

테스트 피라미드는 `E2E 테스트`, `통합 테스트`, `단위 테스트`로 이루어져 있다. 보통 단위 테스트가 80%, 통합 테스트가 15%, E2E 테스트가 5% 정도 된다.

1. 단위 테스트 : 객체나 컴포넌트에 할당된 작은 책임 하나가 예상대로 동작하는지 확인
2. 통합 테스트 : 독립적으로 작성된 객체들의 상호작용 시 발생할 상황을 검증 -> 비즈니스 프로세스의 흐름 검사
3. E2E 테스트 : 사용자에 가장 가까운 테스트로 보통 API 테스트를 의미

단위 테스트가 가장 중요하다. E2E나 통합 테스트의 경우, 여 예외 상황을 커버하지 못하고 쉽게 실패할 수 있다. 또한 테스트 단위가 너무 커서 테스트 실패 이유를 특정하는 것이 어렵다. 심지어 매번 결과가 다른 `비결정적 테스트`가 발생한다.

## 13.1. 구글의 테스트 피라미드

1. 소형 테스트 : 단일 서버, 단일 프로세스, 단일 스레드에서 동작하며, 디스크 I/O나 블로킹 호출이 없는 테스트를 의미
2. 중형 테스트 : 단일 서버, 멀티 프로세스 및 멀티 스레드 허용
3. 대형 테스트 : 멀티 서버

## 13.2. 테스트 분류 기준

1. 테스트가 결정적 인가? (= 일관되는가)
2. 테스트의 속도가 빠른가?

테스트가 비결정적인 가능성이 있으면 안된다. 예를 들어 H2를 통한 테스트 코드는 H2 데이터베이스의 오류로 인해 검증에 실패할 가능성을 가지고 있다. 또한 병렬로 실행했을 때도 문제가 발생할 가능성이 있다. 이런 비결정적 테스트는 신뢰도를 떨어뜨리고, 원인을 파악하기 매우 힘들어진다. 

### 비결정적 테트가 만들어지는 이유
1. 테스트가 병렬 처리를 사용할 경우
2. 테스트가 디스크 I/O를 사용할 겨우
3. 테스트가 다른 프로세스와 통신할 경우
4. 테스트가 외부 서버와 통신할 경우

### 속도가 느린 테스트가 만들어지는 이유
1. 테스트가 블로킹 호출을 사용할 경우
2. 테스트가 디스크 I/O를 사용할 경우
3. 테스트가 다른 프로세스와 통신할 경우
4. 테스트가 외부 서버와 통신할 경우

좋은 테스트는 '결정적이어야 한다', '빨라야 한다' 같은 특징을 가져야 한다. 소형 테스트는 이런 특징을 갖는 것 뿐만 아니라 몇 개가 있든 모든 테스트를 완전히 병렬로 실행할 수 있다. 중형 테스트의 경우 H2를 이용한 테스트를 포함한다. 이는 통합 테스트에 대응되는 개념이다.

## 13.3. 소형 테스트의 중요성
소형 테스트를 작성하려고 노력하다 보면 트랜잭션 스크립트 같은 코드가 나올 확률이 줄어든다. 메서드를 테스트하기 좋게 나누는 과정에서 비즈니스 로직을 도메인에 넣게 되어 책임을 도메인에게 넘길 수 있다.

<br/>

# 14. 테스트 대역
