# 4. 좋은 담위 테스트의 4대 요소
## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

### 4.1.1 첫 번째 요소: 회귀 방지
코드는 재산이 아니라 책임이다. 코드 베이스가 커질수록 잠재먹인 버그에 더 많이 노출된다. 따라서 회귀에 대한 보호를 개발하는 것이 중요하다.

- 테스트 중에 실행되는 코드의 양
- 코드 복잡도
- 코드의 도메인 유의성

실행되는 코드가 많을수록 테스트에서의 회귀가 나타날 가능성이 높다. 최상의 보호를 위해선 해당 라이브러리, 프레임워크 ,외부 시스템을 테스트 범주에 포함시켜 의존성을 검증하는 것이다.

### 4.1.2 두 번째 요소: 리팩터링 내성

> 테스트를 빨간색으로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도

기반 코드를 수정하면 정상적으로 작동되어도 테스트가 빨간색으로 바뀌는 상황이 있다. 이를 `거짓 양성`(허위 경보)이라고 한다.

테스트가 지속 가능한 성장을 하는 매커니즘은 다음과 같다.
- 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다.
- 코드 변경이 회기로 이어지지 않을 것이라고 확신하게 된다.

거짓 양성은 이 두 가지 이점을 방해한다. 이는 타당한 실패도 무시하게 만든다. 또한, 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어진다.

### 4.1.3 무엇이 거짓 양성의 원인인가?
테스트와 SUT의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다. 테스트는 최종 사용자 관점에서 행해져야 한다.

<!-- 내용 이해 못함 -->

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계
### 4.2.1 테스트 정확도 극대화

|  |  | 작동 | 고장 |
| --- | --- | --- | --- |
|  | **테스트 통과** | 올바른 추론 | 2종 오류(거짓 음성) |
|  | **테스트 실패** | 1종 오류(거짓 양성) | 올바른 추론 |

회귀 방지를 통해 거짓음성을 예방할 수 있다. 반대로 거짓 양성의 경우에는 리팩터링 내성이 도움이 된다.

> 테스트 정확도 = 신호(발견된 버그 수) / 소음(허위 경보 발생 수)

허위 경보가 울리지 않더라도 버그를 찾을 수 없는 테스트는 소용이 없다. 반대로 모든 버그를 찾더라도 소음이 많으면 테스트 정확도가 0에 가까워진다.

### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계
거짓 양성(허위 경보)와 거짓 음성(알려지지 않은 버그)는 초기에 중요하지 않다. 초기에는 코드에 대한 기억이 생생하기 때문이다. 그러나 코드 베이스가 커질수록 이런 잡음들은 테스트의 신뢰를 떨어뜨린다. 따라서, 중대형 프로젝트에선 이런 거짓에 대한 주의가 필요하다.

## 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성
- 테스트가 얼마나 이해하기 어려운가? : 테스트 크기는 작을수록 가독성이 올라간다. 테스트 코드를 일등 시민 취급하지 말고 제품 코드만큼 중요하다.
- 테스트가 얼마나 실행하기 어려운가?: 프로세스 외부 의존성으로 작동 시, 의존성을 해결하는데에 많은 시간을 할애하게 된다.

## 4.4 이상적인 테스트를 찾아서

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

네 가지 테스트의 합산을 통해 점수를 내야 테스트를 평가할 수 있다. 

### 4.4.1 이상적인 테스트를 만들 수 있는가?
이상적인 테스트는 만들 수 없다. 왜냐하면 회귀 방지, 리펙터링 내성, 빠른 피드백은 상호 배타적이기 때문이다. 따라선 ,셋 중 하나를 희생해야 나머지 둘을 최대로 할 수 있다. 어떤 것을 희생해야할지 극단적인 사례를 통해 확인해보자.

### 4.4.2 극단적인 사례1: 엔드 투 엔드 테스트
엔드 투 엔드는 많은 코드를 테스트 하기에 회귀 방지를 할 수 있다. 또한 거짓 양성에 면역되어 리팩터링 내성도 우수하다. 왜냐하면 최종 사용자 관점에서 세부 구현은 중요하지 않기 때문이다. 그러나 엔드 투 엔드는 느리다는 단점이 존재한다.

### 4.4.3 극단적인 사례2: 간단한 테스트
```java
@Test
void tests() {

    User sut = new User;

    String name = sut.getName();

    assertThat(name).isEqualTo("Jhon Smith");
}
```

위와 같이 단순한 코드는 거짓 양성이 생길 가능성이 적어 리팩터링 내성에 강력하다. 또한 매우 빠른 피드백도 가능하다. 그러나 너무 짧이 때문에 회귀 방지에 특화되지 않는다.

### 4.4.4 극단적인 사례3: 깨지기 쉬운 테스트

UserRepository를 통해 findById()를 수행한다고 가정해보자. findById()에는 어떤 SQL이 들어가도 결과만 같으면 상관없다. 이는 리팩터링 내성에 취약하다는 단점이 있다.

### 4.4.5 이상적인 테스트를 찾아서: 결론
| 이름 | 리펙터링 내성 | 회귀 방지 | 빠른 피드백 |
| ------ | :-: | :-: | :-: |
| **엔드 투 엔드 테스트** | O | O | X |
| **간단한 테스트** | O | X | O |
| **깨지기 쉬운 테스트** | X | O | O |

어떤 특성도 0이 되어서는 안된다. 그렇다면 어떤 요소를 희생해야할까?

`리팩터링 내성`을 포기할 수 없는 이유는 테스트에 리팩터링 내성이 있거나 없거나 둘 중 하나이기 때문이다. 따라서, 리펙터링 내성을 최대화하면서 `빠른 피드백`과 `회귀 방지`에서 적절한 타협을 이루는 거이 좋다.

> **[ CAP 정리 ]**
>
> 분산 데이터 저장소는 다음 세 가지 보증 모두를 동시에 제공할 수 없다.
>
> - 일관성: 모든 읽기가 최근의 응답을 반영할 것
> - 가용성: 모든 요청이 응답을 수신하는 것
> - 분할 내성: 네트워크 분할에도 시스템이 계속 작동할 것

## 4.5 대중적인 테스트 자동화 개념 살펴보기
테스트 피라미드는 테스트 유형의 적절한 비율을 나타내는 모형이다.

단위 테스트는 속도가 가장 빠르기 때문에 가장 많이 있는 반면, 엔드 투 엔드 테스트의 경우 속도가 매우 느리다는 점때문에 많은 비율을 차지하지 않는다. 그러나 어느 계층이더라도 리펙터링 내성을 최대로 가져가야하는 거은 변하지 않는다.

### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

> - 블랙박스 테스트: 시스템 내부 구조를 몰라도 시스템 기능을 검사하는 테스트 방법. 무엇을 해야하는지를 중심으로 구축
> - 화이트박스 테스트: 애플리케이션 내부 작업을 검증. 소스 코드에서 파생

|  | 회귀 방지 | 리펙터링 내성 |
|---|---|---|
| **화이트박스 테스트** | 좋음 | 나쁨 |
| **블랙박스 테스트** | 나쁨 | 좋음 |

화이트박스 테스트의 경우, 소스코드에 의존하기 때문에 테스트 대상 코드과 결합하게 된다. 이는 테스트가 쉽게 깨질 수 있어 리팩터링 내성이 나쁘다.

리팩터링 내성은 타협할 수 없기 때문에 블랙바스 테스트를 통해 진행하는 것이 바람직하다. 그러나 테스트를 분석할 때는 화이트박스 방법을을 사용할 수 있다. 결국 두 가지 방법을 적절히 사용하는 것이 좋다.

<br/>

# 5. 목과 테스트 취약성

## 5.1 목과 스텁 구분
테스트 더블은 크게 목(목, 스파이)과 스텁(스텁, 더미, 페이크)로 나뉜다.

- 목은 외부로 나가는 상호 작용을 모방하고 검사하는데 도움이 됨. 즉, SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당
- 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 즉, SUT가 입력 데이ㅓ를 얻기 위한 의존성을 호출하는 것에 해당

목은 SUT와 관련 의존성 간의 상호작용을 모방하고 검사한다. 반면 스텁은 모방만 한다.

### 5.1.2 도구로서의 목과 테스트 대역으로서의 목
```java
class emailTest {

    @Mock
    private IEmailGateway mock;

    @Test
    void sending_a_greetings_email() {
        Controller sut = new Controller(mock);

    }
}
```

여기서 사용되는 mock은 테스트 대역으로서의 목을 의미하고, Mock 클래스는 도구로서의 목을 의미한다.
또한 만약 mock 인스턴스에 sutb 추가된 경우 목이 아님을 명심하자.

### 5.1.3 스텁으로 상호 작용을 검증하지 말라
```java
@Test
void creting_a_report() {
    var stub = Mockito.mock(IDatabase.class);
    when(stub.getNumberOfUser()).thenReturn(10);

    var sut = new Controller(stub);
    Report report = sut.createReport();

    verify(stub).getNumberOfUser();
}
```

최종 결과가 아닌 사항을 검증하는 `과잉 명세`의 예시이다. 테스트가 스텁과의 상호작용을 확인하기 때문에 테스트 취약성을 초래한다.

### 5.1.4 목과 스텁 함께 쓰기
```java
@Test
void purchase_fails_when_not_enough_inventory() {
    var storeMock = Mockito.mock(IStore.class);
    when(stub.hasEnoughInventory(eq(Product.Shampoo, eq(5))))
        .thenReturn(false);
    var sut = new Customer();

    bool success = sut.purchase(
        storeMock,
        Product.Shampoo,
        5
    );

    assertThat(sucess).isEqualTo(false);
    verify(storeMock).removeInventory(Product.Shampoo, 5, Times.Never);
}
```
이 경우, hasEnoughInventory()에 응답을 설정한 다음 removeInventory()가 호출됬는지 검즈안다. 이는 위배되지 않는 예시이다.

### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
명령과 조회를 하나의 메서드에서 분리시켜야 한다는 CQS 원칙에 따라 목과 스텁을 구분해서 사용해야 한다. `명령`의 경우 반환 값이 없지만 부작용을 초래하기 때문에 목을 사용해햐하고, `조회`의 경우 값을 반환하지만 부작용이 없기 때문에 스텁을 사용하는 것이 좋다.

## 5.2 식별할 수 있는 동작과 구현 세부 사항
테스트에 거짓 양성(허위 경보)가 발생하는 이유는 코드의 구현 세부 사항과 결합돼 있기 때문이다. 이런 강결합을 피하기 위해 다음과 같은 사항들을 고려해야한다.

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다
모든 코드는 2차원으로 분류 된다.
- 공개 API 또는 비공개 API
- 식별할 수 있는 동작 또는 구현 세부 사항

공개, 비공개 API의 경우 접근제어자(private, public 등)을 통해 구분이 가능하다.  식별할 수 있는 동작일면 다음 중 하나여야 한다.

- 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산 수행 혹은 부작용을 초래 혹은 둘 다하는 메서드이다.
- 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.

잘 설계된 API는 `식별할 수 있는 동작`과 `공개 API`가 일치한다. 그러나 종종 시스템의 구현 세부 사항이 노출되기 시작한다.

### 5.2.2 구현 세부 사항 유출: 연산의 예

이름을 업데이트하는 메서드가 있다고 해보자. 이를 변경하기 위해 UserController는 name 필드에 직접 접근하여 값을 변경할 수도 있다.

```java
class User {

    public String name;

    public String normalizeName(String name) {
        String result = String.trim(name);

        if(result.length > 50)
            return result.subtring(0, 50);

        return result;
    }
}


class UserController {

    public void renameUser(String newName, int userId) {
        User user = getUserFromDatabase(userId);

        String normalizedName = user.nomalizeName(newName);
        user.name = normalizedName;

        saveUserToDatabase(user);
    }
}
```


- `이름`: 식별할 수 있는 동작이면서 공개 API
- `정규화된 이름`: 구현 세부 사항이면서 공개 API -> **구현 세부 사항 유출**

따라서 이를 setter에 정규화된 이름을 비공개하여 해결이 가능하다.

```java
class User {

    private String name;

    public void setName(String newName) {
        this.name = normalizeName(newName);
    }

    public String normalizeName(String name) {
        String result = String.trim(name);

        if(result.length > 50)
            return result.subtring(0, 50);

        return result;
    }
}


class UserController {

    public void renameUser(String newName, int userId) {
        User user = getUserFromDatabase(userId);

        user.setName(normalizedName);

        saveUserToDatabase(user);
    }
}
```

### 5.2.3 잘 설계된 API와 캡슐화
장기적으로 코드베이스 유지 보수를 위해 캡슐화가 중요하다. 그 이유는 코드 복잡도를 줄여 개발 속도 향상과 버그 감소를 이룰 수 있다.

- 구현 세부 사항을 숨겨 내부 손상을 방지함
- 연산이 클래스의 불변성을 위반하지 않도록 함

### 5.2.4 구현 세부 사항 유출: 상태의 예

## 5.3 목과 테스트 취약성 간의 관계
### 5.3.1 육각형 아키텍처 정의
애플리케이션 계층과 도메인 계층(비즈니스 로직)을 분리하여 조직의 경쟁력을 향상시킨다. 

- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
- 애플리케이션 내부 통신: 애플리케이션 계층 -> 도메인 계층으로의 단방향 의존만 지향한다. 따라서, 외부 환경과 도메인 계층을 완전 격리가 가능하다.
- 애프리케이션 간의 통신: 외부 애플리케이션은 도메인 계층에 직접 접근할 수 없다.

### 5.3.2 시스템 내부 통신과 시스템 간 통신
연산을 수행하기 위한 여러 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 구현 세부 사항에 해당한다. 따라서, 이런 시스템 내부 통신은 테스트가 취약해진다.

반대로 시스템 간 통신은 두 애플리케이션 간 소통을 위한 형식이 정해져있기 때문에 목을 사용한 테스트가 간편하다. 반대로 시스템 내부 통신은 구현 세부 사항과 결합되며 리팩터링 내성 지표가 미흡해진다.

### 5.3.3 시스템 내부 통신과 시스템 간 통신의 예
예를 들어
- 고객이 상점에서 제품을 구매한다
- 매장 내 제품 수량이 충분하면
    - 재고가 상점에서 줄어든다.
    - 고객에게 이메일로 영수증을 발송한다.
    - 확인 내역을 반환한다.

```java
class CustomerController {
    public bool purchase(int customerId, int productId, int quantity) {
        Customer customer = _customerRepository.getById(customerId);
        Product product - _productRepository.getById(productId);

        bool isSuccess = customer.purchase(_mainStore, product, quantity);

        if(isSuccess) {
            _emailGateway.sendReceipt( customer.email, product.name, quantity);
        }
        return isSuccess;
    }
}
```

이 코드에 대해 `이메일 발생 테스트`와 재고가 `충분할 때 구매가 되는 테스트`를 진행해보자.

```java
@Test
void successful_purchase() {
    var mock = Mockito.mock(IEmailGateway);
    var sut = new CustomerController(mock);

    bool isSuccess = sut.purchase(1, 2, 5);

    assertThat(isSuccess).isEqualTo(true);
    verify(mock).sendReceipt(eq("customer@email.com"), eq("shampoo"), 5);
}
```


```java
@Test
void successful_purchase() {
    var storeMock = Mockito.mock(IStore);
    when(storeMock.hasEnoughInventory()).thenReturn(true);
    var customer = new Customer();

    bool isSuccess = customer.purchase(1, 2, 5);

    assertThat(isSuccess).isEqualTo(true);
    verify(storeMock).removeInventory();
}
```

두 번째 테스트의 경우 목표를 달성하는데 도움이 되는 연산이나 상태가 아니기 때문에 테스트하기가 어려워졌다. 또한 removeInventory()의 경우 구현 세부 사항이기에 취약한 테스트라고 볼 수 있다.

## 5.4 단위 테스트의 고전파와 런던파 재고
런던파는 무분별한 목 사용으로 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다. 그러나 고전파는 테스트간의 공유하는 의존성만 교체하기 때문에 리팩터링 내성이 저하되는 문제를 해결할 수 있다.

### 5.4.1 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다

만약 외부 애플리케잇ㄴ을 통해서만 외부 의존성이 접근 가능한 경우에 이를 대체할 순 없다. 그러나 외부 시스템에 대해 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없다면, 하위 호환성 요구 사항은 사라진다. 이러한 시스템 통신 패턴은 구현 세부 사항이 된다.

예를 들어 애플리케이션 데이터베이스는 외부 시스템도 접근이 불가능하다. 완전히 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트로 이어진다. 따라서 데이터베이스와 애플리케이션은 하나의 시스템으로 취급해야 하다. 이는 피드백 속도가 저하된다는 문제가 있긴 하다.

### 5.4.2 목을 사용한 동작 검증

<br/>

# 6. 단위 테스트 스타일
