# 정의

## TSID(Time‑Sorted Unique Identifier)
### 개요
- 생성 시점 기준으로 정렬 가능한 64비트 고유 ID
- Snowflake와 ULID 아이디어를 결합한 형태의 ID 생성 전략​

### 구조와 표현 방식
전반부는 밀리초 단위 타임스탬프(대략 41~42비트), 후반부는 노드 ID와 카운터/랜덤 비트(대략 22비트)로 구성된 `64비트 값`
​
64비트 정수(Bigint) 형태나 13자리 Base32 문자열로 표현할 수 있어, UUID보다 훨씬 짧다.
​

### 특징
생성 시간이 앞선 TSID가 항상 더 작은 값이라 단조 증가에 가깝고, 이 때문에 B‑Tree 기반 인덱스(예: MySQL InnoDB)의 페이지 분할과 조각화를 줄인다.
​
노드 ID와 카운터를 포함해 분산된 여러 인스턴스에서 동시에 생성해도 충돌 확률이 매우 낮고, DB 없이 애플리케이션 레벨에서 ID를 선점할 수 있다.
​

UUID란 무엇인가
정의
UUID(Universally Unique Identifier)는 128비트 길이의 전역 고유 식별자로, 주로 RFC 4122 규격에 따라 여러 버전(v1, v4, v7 등)으로 사용된다.
​
일반적으로 32자리 16진수(하이픈 포함 시 36문자 문자열)로 표현되며, 운영체제·언어 표준 라이브러리에서 기본 제공된다.
​

구조와 버전

`128비트` 중 일부는 버전 정보·변형 비트로 사용되며, 나머지가 시간·노드·랜덤 값 등으로 채워진다.
​

자주 쓰는 버전

v4: 대부분의 비트가 난수인 랜덤 기반 UUID로, 시간순 정렬이 불가능하다.
​

v1: 시간+노드(MAC) 기반으로 어느 정도 시간순 정렬이 되지만, 프라이버시 이슈와 구현상의 제약이 있다.
​

v7: 타임스탬프를 앞부분에 두어 “시간 정렬 가능”하게 만든 최신 스펙으로, v4의 단점을 보완하려는 목적이다.
​

DB에서의 특징

128비트라 인덱스 크기가 크고, 특히 v4처럼 랜덤한 값은 클러스터드 인덱스 삽입 시 페이지 split과 랜덤 I/O를 많이 유발해 쓰기 성능에 악영향을 줄 수 있다.
​

문자열(CHAR(36))로 저장하면 공간과 캐시 효율이 더 나빠지므로, 많이들 BINARY(16)에 packed 형태로 저장해 오버헤드를 줄인다.
​