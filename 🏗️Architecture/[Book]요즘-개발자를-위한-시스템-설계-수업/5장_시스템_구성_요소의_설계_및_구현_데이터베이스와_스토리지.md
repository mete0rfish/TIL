# 5.1 데이터베이스
- 데이터 구성: DB는 데이터를 구조적이고 체계적으로 저장하는 방식
- 데이터 검색: DB는 빠르고 효율적으로 데이터 검색이 가능
- 데이터 무결성: 제약 조건, 관계, 검증 규칙을 이용하여 데이터 무결성을 유지
- 데이터 보안: 사용자 인증, 권한 부여, 암호화 등으로 유출을 막음
- 데이터 일관성: 트랜잭션 관리와 ACID 특성으로 데이터 일관성 유지

하나의 DB 유형이 모든 시스템과 애플리케이션의 요구 사항을 모두 충족할 수 없다는 점이 중요

## 5.1.1 데이터베이스 유형
관계형과 NoSQL로 분류

## 5.1.2 관계형 데이터베이스
- 테이블: 관계형 DB는 데이터를 테이블 형태로 표현
- 행: 레코드, 튜플
- 열: 속성, 필드
- 키: 키로 테이블 간 관계 설정
- 정규화: 데이터 중복을 제거하고 데이터 무결성을 높이는 데 사용
- SQL: RDB와 상호작용하는 언어
- ACID 특성
- 트랜잭션

## 5.1.3 NoSQL
- 키-값 저장소: 검색에 특화(Redis, DynamoDB, Riak)
- 문서 지향 데이터베이스: JSON이나 XML같은 문서로 저장, 주로 웹 애플리케이션에서 사용 (MongoDB, CouchDB)
- 컬럼 패밀리 데이터베이스: 관련 데이터를 컬럼 패밀리라는 그룹으로 구성 (아파치 카산드라, HBase, ScyllaDB)
- 그래프 기반 데이터베이스: 복잡한 관계를 표현하는 데이터를 위해 설계 (Neo4j, Neptune)

## 5.1.4 관계형 DB와 비관계형 DB 장단점
### 관계형 DB
- 장점
  - 데이터 중복 처리
  - 강력한 보안 기능
  - ACID 트랜잭션
- 단점
  - 성능: 복잡한 조인의 경우 성능 저하
  - 메모리 소모량: 행과 열이 저장 공간을 차지하며, null 값이 있어도 메모리 사용량 증가
  - 복잡성
  - 수평적 확장의 어려움

### 비관계형 DB
- 장점
  - 유연한 데이터 모델
  - 스키마 업데이트
  - 수평적 ㅗ학장
- 단점
  - 아직 부족한 표준화
  - ACID 트랜잭션 미지원

# 5.2 키-값 저장소
## 5.2.1 키-값 저장소
- 고유한 키가 특정 값과 연결되는 데이터 저장 방식
- 대규모 분산 딕셔너리나 분산 해시 테이블
- 읽기 쓰기 작업 효율성이 높음

## 5.2.2 분산
- 확장성
- 성능
- 유연성
- 장애 허용성

## 5.2.3 키-값 저장소 설계
### 기능적 요구 사항
- Put(key, value): 키-값 쌍을 저장소에 삽입. 해당 키 있다면 기존 값을 업데이트
- Get(Key): 지정된 키에 연결된 값을 검색. 없으면 오류 메시지 반환
- Delete(key): 주어진 키-값 쌍 삭제

### 비기능적 요구 사항
- 확장성
- 성능
- 내구성
- 일관성
- 가용성
- 파티션 허용성

# 5.3 확장성과 데이터 복제의 최적화
## 5.3.1 확장성 강화
여러 노드에 요청을 고르게 분배할 때 해시를 사용한다.
이 방식은 노드를 추가하거나 제거할 때 비효율적이다.
상당수 키를 이동해야 하기 때문이다.

## 5.3.2 일관된 해싱 사용
![5-2](image.png)
일관된 해싱은 노드 집합에 부하를 효과적으로 분산하는 방식
일관된 해싱을 사용해서는 균등하게 부하 분산이 불가능하다.
서버가 대용량 데이터를 처리하면 해당 서버가 병목 지점이 되어 전체 성능을 저하시키는 핫스팟이 발생한다.

## 5.3.3 가상 노드 사용
- 단일 해시 함수 대신 동일한 키에 여러 해시 함수를 적용하는 방식
- 특정 노드가 다른 노드보다 더 많은 저장 공간을 갖고 있으면, 추가 해시 함수를 사용해 더 많은 가상 노드를 생성할 수 있다.

### 가상 노드 장점
- 노드 장애가 생겨도 다른 노드에 고르게 분산 가능
- 노드는 물리적 장비의 성능 차이를 고려해 담당할 가상 노드 개수 조정 가능
  - 예를 들어 특정 노드의 계산 능력이 두 배 정도 크다면 더 많은 작업 처리하도록 설정 가능

## 5.3.4 데이터 복제 전략
### 주종 모델
- 주 저장소는 쓰기 요청을 처리하며, 종 저장소는 주 저장소의 데이터를 복제하고 읽기 요청을 담당
- 쓰기 작업 이후에 복제가 되므로 복제 지연이 발생
- 주 저장소에 장애가 발생하면 시스템 쓰기 기능이 중단되어 SPoF 문제 발생 가능

### 동등 모델
- 모든 노드에 데이터를 복제하는 것은 비효율적이고 비용이 많이 듬
  - 보통 노드를 세 개 내지 다섯 개만 성택해서 데이터 복제하는 방법을 사용
- 여러 호스트에 데이터를 분산하여 저장함으로써 내구성과 높은 가용성을 확보하는 데 효과적
- 읽기나 쓰기 작업을 처리하는 노드를 `코디네이터`라고 하며, 특정 키를 직접 책임짐

# 5.4 get 및 put 함수 구현
- 시스템 설계의 핵심 요구 사항 중 하나는 구성 가능성
  - 가용성, 일관성, 비용 효율성과 효율성 간의 균형을 조정
- 클라이언트는 두 가지 방식으로 노드를 선택
  1. 요청을 일반 로드 밸런서로 라우팅하는 방식
  2. 분할 인식 클라이언트 라이브러리를 사용해 요청을 해당 코디네이터 노드로 직접 전달하는 방식

- 첫 번째 방식: 클라이언트가 코드에 종속되지 않도록 해야 함
- 두 번째 방식: 클라이언트가 특정 서버에 직접 접근할 수 있어 홉 수가 줄어들어 지연 시간을 낮출 수 잇음

## 5.4.2 r과 w 사용
- r: 읽기 작업이 성공하는 데 필요한 최소 노드 개수
- w: 쓰기 작업이 성공하는 데 필요한 최소 노드 개수
- r + w > n이라는 조건을 만족해야, 읽기 작업이 항상 최신 쓰기 데이터를 접근하도록 보장함

# 5.5 키 값 저장소의 장애 허용성과 장애 식별
## 5.5.1 일시적 장애 관리
- 일반적으로 `쿼럼 기반 시스템`으로 분산 시스템에서 장애를 처리함

# 5.7 DynamoDb
