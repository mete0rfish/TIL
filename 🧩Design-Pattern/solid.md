# SOLID
1.  SRP(Single Responsibility Principle) - 단일 책임원칙
    - 하나의 클래스는 하나의 책임만 가지자.

2. OCP(Open-Closed Principle) - 개방-폐쇄 원칙
    - 확장에는 열려 있어야 하고, 변경에는 닫혀있어야 함.
    - if (type == "KAKAO") 처럼 하드 코딩 대신 Payment 인터페이스에 Kakaopay, NaverPay 라는 구현체를 만들어서 사용하면 클래스만 추가하면 된다.

3. LSP (Liskov Subsitution Principle) - 리스코프 치환 원칙
    - 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.
    - 만약 자식 클래스와 부모 클래스의 속성이 다르면, 메서드의 멱등성이 보장되지 않는다.

4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙
    - 클라이언트가 자신이 사용하지 않는 메서드에 의존하도록 강요받으면 안된다.
    - 프린터 클래스는 복합기 인터페이스를 구현하지만 팩스()와 복사() 는 사용하지 않아 빈 껍데기로 남는다.
      - Printable, Faxable, Copyable 인터페이스로 쪼개 Printable만 구현하도록 수정

5. DIP (Dependency Inversion Principle) - 의존성 역전 원칙
    - 구체적인 것에 의존하지 말고, 추상적인 것에 의존해야 한다.


# 왜 사용하는가?
요구 사항은 언제든지 변하기 때문에, 그 상황에서 빠르게 소프트웨어를 변형시키기 위해서 필요하다.
따라서, SOLID는 이런 변화에 유연하게 대처할 수 있는 지속 가능한 코드를 위한 지침이다.

## 1. 유지보수성과 확장성
기능 추가 시, 변경에 취약해지기 쉽다. 이를 방지하기 위해 OCP와 DIP를 지키도록 하자.
OCP와 DIP를 통해 호출하는 메서드에서 코드 수정이 발생하지 않도록

## 2. 결합도는 낮추고, 응집도는 높이기
- SRP와 iSP는 클래스나 모듈이 한 가지 목적에만 집중하게 하여 응집도를 높인다.
- DIP는 구체적인 구현체가 아닌 추상화에 의존하게 하여 객체 간 결합도를 낮춘다.

## 3. 테스트 용이성
DIP를 적용해, 외부 API에 대해서 Mock 객체를 주입하여 테스트할 수 있다.
